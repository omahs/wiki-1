"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[6624],{3905:(t,e,a)=>{a.d(e,{Zo:()=>p,kt:()=>d});var n=a(7294);function o(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function i(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function s(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?i(Object(a),!0).forEach((function(e){o(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function r(t,e){if(null==t)return{};var a,n,o=function(t,e){if(null==t)return{};var a,n,o={},i=Object.keys(t);for(n=0;n<i.length;n++)a=i[n],e.indexOf(a)>=0||(o[a]=t[a]);return o}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(n=0;n<i.length;n++)a=i[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(o[a]=t[a])}return o}var c=n.createContext({}),l=function(t){var e=n.useContext(c),a=e;return t&&(a="function"==typeof t?t(e):s(s({},e),t)),a},p=function(t){var e=l(t.components);return n.createElement(c.Provider,{value:e},t.children)},h={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(t,e){var a=t.components,o=t.mdxType,i=t.originalType,c=t.parentName,p=r(t,["components","mdxType","originalType","parentName"]),m=l(a),d=o,g=m["".concat(c,".").concat(d)]||m[d]||h[d]||i;return a?n.createElement(g,s(s({ref:e},p),{},{components:a})):n.createElement(g,s({ref:e},p))}));function d(t,e){var a=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var i=a.length,s=new Array(i);s[0]=m;var r={};for(var c in e)hasOwnProperty.call(e,c)&&(r[c]=e[c]);r.originalType=t,r.mdxType="string"==typeof t?t:o,s[1]=r;for(var l=2;l<i;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},9513:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var n=a(7462),o=(a(7294),a(3905));const i={sidebar_label:"Consistency and Reliability",sidebar_position:9},s="Ensuring reliability in asyn\u0441 programming",r={unversionedId:"developing-contracts/distributed_transactions",id:"developing-contracts/distributed_transactions",title:"Ensuring reliability in asyn\u0441 programming",description:"One of the key features of the Gear Protocol is its use of the Actor model for message-passing communication. The Actor model framework enables asynchronous messaging and parallel computation, which  drastically improves the achievable speed and scalability of dApps. In the Actor model, programs do not share state and instead communicate with each other through messages. If a program sends an asynchronous message to another program, it has to wait for a reply from the other program before it can proceed with the next operation.",source:"@site/docs/developing-contracts/distributed_transactions.md",sourceDirName:"developing-contracts",slug:"/developing-contracts/distributed_transactions",permalink:"/docs/developing-contracts/distributed_transactions",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/developing-contracts/distributed_transactions.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_label:"Consistency and Reliability",sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Delayed Messages",permalink:"/docs/developing-contracts/delayed-messages"},next:{title:"System Signals",permalink:"/docs/developing-contracts/system-signals"}},c={},l=[{value:"Splitting a token swap transaction into 3 separate transactions",id:"splitting-a-token-swap-transaction-into-3-separate-transactions",level:2},{value:"Two phase commit protocol",id:"two-phase-commit-protocol",level:2},{value:"Three phase commit protocol.",id:"three-phase-commit-protocol",level:2},{value:"Saga pattern",id:"saga-pattern",level:2}],p={toc:l};function h(t){let{components:e,...i}=t;return(0,o.kt)("wrapper",(0,n.Z)({},p,i,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"ensuring-reliability-in-asyn\u0441-programming"},"Ensuring reliability in asyn\u0441 programming"),(0,o.kt)("p",null,"One of the key features of the Gear Protocol is its use of the Actor model for message-passing communication. The Actor model framework enables asynchronous messaging and parallel computation, which  drastically improves the achievable speed and scalability of dApps. In the Actor model, programs do not share state and instead communicate with each other through messages. If a program sends an asynchronous message to another program, it has to wait for a reply from the other program before it can proceed with the next operation."),(0,o.kt)("p",null,'When a program interacts with another program, the transaction becomes "distributed." A distributed transaction is a set of operations performed across multiple databases or, in the case of the Gear Protocol, across multiple actors with their own states. Distributed transactions must possess these properties:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Atomicity - all data changes are treated as if they were a single operation. That is, either all of the modifications are made, or none of them are made;"),(0,o.kt)("li",{parentName:"ul"},"Consistency - this property implies that when a transaction begins and ends, the state of data is consistent.")),(0,o.kt)("p",null,"For example, transactions on the Ethereum blockchain are atomic, meaning that if a transaction fails due to an error, all of its effects on the global state are rolled back as if the transaction never occurred. Many blockchain applications rely on the atomicity of transactions, but this can be a problem when building asynchronous applications using the programming paradigm used on Ethereum, as you may encounter the problem of not being able to recover program state after a failed transaction."),(0,o.kt)("p",null,"Consider a simple token exchange where a user wants to swap tokens A for tokens B in a liquidity pool. The swap contract would send a message to the token A contract and a message to the token B contract. If one of these messages succeeds and the other fails for some reason, the state of the token A contract would be changed while the state of the token B contract would remain unchanged. This can cause inconsistencies in the state of the data and make it difficult to recover from failed transactions. As a result, it is important to consider different programming paradigms for implementing distributed transactions."),(0,o.kt)("p",null,"Let's look at different programming methods using the example of a token exchange."),(0,o.kt)("h2",{id:"splitting-a-token-swap-transaction-into-3-separate-transactions"},"Splitting a token swap transaction into 3 separate transactions"),(0,o.kt)("p",null,"Consider the following situation: we have a liquidity pool of token A and token B, and also a user who wants to exchange his tokens A for tokens B."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Step 1")," : A user sends a ",(0,o.kt)("inlineCode",{parentName:"p"},"MakeOrder")," message to the swap contract. During that transaction the contract sends a message to the fungible token contract. The result of executing this message can be a success or a failure. The worst case scenario is having a lack of gas when processing a message in the token contract or in the subsequent execution of the swap contract. However, since the token contract supports idempotency, the user can simply restart the transaction and complete it."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img alt",src:a(6836).Z+"#gh-light-mode-only",width:"2197",height:"580"}),"\n",(0,o.kt)("img",{alt:"img alt",src:a(3593).Z+"#gh-dark-mode-only",width:"2197",height:"580"})),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Step 2"),":  A user sends an ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteOrder")," message to the swap contract. The swap contract just calculates the amount of tokens a user will receive and saves the new state of the liquidity poll."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img alt",src:a(8413).Z+"#gh-light-mode-only",width:"1387",height:"466"}),"\n",(0,o.kt)("img",{alt:"img alt",src:a(2013).Z+"#gh-dark-mode-only",width:"1387",height:"466"})),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Step 3"),":  A user sends a ",(0,o.kt)("inlineCode",{parentName:"p"},"Withdraw")," message to the swap contract and receives tokens B. The situation here is the same as in the first step."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img alt",src:a(9145).Z+"#gh-light-mode-only",width:"2206",height:"550"}),"\n",(0,o.kt)("img",{alt:"img alt",src:a(3348).Z+"#gh-dark-mode-only",width:"2206",height:"550"})),(0,o.kt)("p",null,"It is possible to execute a swap in one transaction. To resolve the problem of atomicity we can use the following patterns here:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"2 PC - 2 Phase Commit protocol")," (And also its extension - 3 phase commit protocol);"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Saga Pattern"),".")),(0,o.kt)("h2",{id:"two-phase-commit-protocol"},"Two phase commit protocol"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Theory"),":\nWe have a coordinator that sends messages to participants. The ",(0,o.kt)("inlineCode",{parentName:"p"},"two-phase commit protocol")," has two parts: the ",(0,o.kt)("inlineCode",{parentName:"p"},"prepare")," phase and the ",(0,o.kt)("inlineCode",{parentName:"p"},"commit")," phase."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Preparation phase:"),"\nDuring the preparation phase, the coordinator and participants perform the following dialog:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Coordinator"),":\nThe coordinator directs each participant database server to prepare to commit the transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Participants"),":\nEvery participant notifies the coordinator whether it can commit to its transaction branch."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Coordinator"),":\nThe coordinator, based on the response from each participant, decides whether to commit or roll back the transaction. It decides to commit only if all participants indicate that they can commit to their transaction branches. If any participant indicates that it is not ready to commit to its transaction branch (or if it does not respond), the coordinator decides to end the global transaction.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Commit phase:")),(0,o.kt)("p",null,"During the commit phase, the coordinator and participants perform the following dialog:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Coordinator"),":\nThe coordinator writes the commit record or rollback record to the coordinator's logical log and then directs each participant to either commit or roll back the transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Participants"),":\nIf the coordinator issued a commit message, the participants commit the transaction by writing the commit record to the logical log and then sending a message to the coordinator acknowledging that the transaction was committed. If the coordinator issued a rollback message, the participants roll back the transaction but do not send an acknowledgment to the coordinator."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Coordinator"),":\nIf the coordinator issues a message to commit the transaction, it waits to receive acknowledgment from each participant before it ends the global transaction. If the coordinator issued a message to roll back the transaction, it does not wait for acknowledgments from the participants.")),(0,o.kt)("p",null,"Let's see how it can be used in the example of a token swap contract. We consider the following situation: the account wants to exchange his tokens (let\u2019s call it tokenA) for other tokens (tokenB) using the liquidity pool in the swap contract."),(0,o.kt)("p",null,"In that case the swap contract is a coordinator contract and tokens contracts are participants."),(0,o.kt)("p",null,"The swap contract makes the following steps:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Prepare phase")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Swap contract:"),"\nSwap contract sends the messages to token contracts to prepare transfer tokens (Messages can be sent in parallel). In fact, token contracts must lock funds at this stage."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Token contract"),":\nToken contracts make all necessary checks, and in case of success, lock funds and reply to the swap contract that they are ready to make a transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Swap contract"),":\nSwap contract handles the messages from the token contracts and decides whether to commit or abort the global transaction.\nreceives tokens B. The situation here is the same as in the first step.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img alt",src:a(1786).Z+"#gh-light-mode-only",width:"1603",height:"853"}),"\n",(0,o.kt)("img",{alt:"img alt",src:a(3225).Z+"#gh-dark-mode-only",width:"1603",height:"853"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Commit phase")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Swap contract"),":\nIf token contracts confirm their readiness to execute the transaction, the swap contract sends them a message to commit the state. Otherwise, the swap contract tells them to abort the transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Token contract"),":\nToken contracts finally change their state and send replies to the swap contract;"),(0,o.kt)("li",{parentName:"ul"},"`Swap contracts:\nSwap contract handles the messages from the token contracts and saves the result about transaction execution.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img alt",src:a(5401).Z+"#gh-light-mode-only",width:"1516",height:"853"}),"\n",(0,o.kt)("img",{alt:"img alt",src:a(5209).Z+"#gh-dark-mode-only",width:"1516",height:"853"})),(0,o.kt)("p",null,"Of course, all that workflow handles the case when the gas runs out during the message execution."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Pros:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Messages can be sent in parallel;"),(0,o.kt)("li",{parentName:"ul"},"If cases with a lack of gas are taken into account, then the data consistency is achieved.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Cons:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The participants have to wait for the message from the coordinator, they can\u2019t commit or abort themselves;"),(0,o.kt)("li",{parentName:"ul"},"The coordinator plays an important role: if it fails to send the message then all participants go to the blocked state (in our example: the funds in token contracts are blocked).")),(0,o.kt)("h2",{id:"three-phase-commit-protocol"},"Three phase commit protocol."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Theory"),": It is similar to two-phase commit protocol but it tries to solve the problems with blocking the state of participants and to give the participants the opportunity to recover their states themselves."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Prepare phase:"),"\nThe same steps of two phase commit protocol are followed here:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Coordinator"),":\nThe coordinator sends a prepare message to all participants and waits for replies;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Participants"),":\nIf the participants are ready to commit a transaction they send the ready message, otherwise they send no message to the coordinator."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Coordinator"),":\nBased on replies the coordinator decides either to go to the next state or not. If any of the participants respond with no message or if any of the participants fails to respond within a defined time, the coordinator sends an abort message to every participant.  It is important to highlight the differences from two phase commit protocol:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The coordinator limits the response time from the participant. We can implement this by sending a message with an indicated amount of gas or indicated number of blocks the coordinator is ready to wait;"),(0,o.kt)("li",{parentName:"ul"},"If the coordinator fails at this state, then the participants are able to abort the transaction (i.e. unlock their state) using delayed messages. So, in that phase, the timeout cases abort.")))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Prepare-to-commit phase:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Coordinator"),":\nThe coordinator sends a prepare-to-commit message to all participants and gets acknowledgements from everyone;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Participants"),":\nReceiving a prepare-to-commit message, a participant knows that the unanimous decision was to commit. As was already mentioned in the prepare phase, if a participant fails to receive this message in time, then it aborts. However, if a participant receives an abort message then it can immediately abort the transaction.\nThe possible problem: the coordinator fails during sending a prepare-to-commit to participants. So some participants are in phase 2, others are in phase 1. It's a disaster because the first group will commit, the second group will abort in case of timeout.\nSo we have to make sure that If one of the participants has received a precommit message, they can all commit. If the coordinator falls, any of the participants, being at the second stage, can become the coordinator itself and continue the transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Coordinator"),":\nHaving received acknowledgements from all the participants, the coordinator goes to the next phase.")),(0,o.kt)("p",null,"The three-phase commit protocol accomplishes two things:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Enables use of a ",(0,o.kt)("inlineCode",{parentName:"li"},"recovery coordinator")," (it can be a coordinator itself that starts a new transaction, or a participant). If a coordinator died, a recovery coordinator can query a participant.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If the participant is found to be in phase 2, that means that every participant has completed phase 1 and voted on the outcome. The completion of phase 1 is guaranteed. It is possible that some participants may have received commit requests (phase 3). The recovery coordinator can safely resume at phase 2."),(0,o.kt)("li",{parentName:"ul"},"If the participant was in phase 1, that means NO participant has started commits or aborts. The protocol can start at the beginning."),(0,o.kt)("li",{parentName:"ul"},"If the participant was in phase 3, the coordinator can continue in phase 3 \u2013 and make sure everyone gets the commit/abort request"))),(0,o.kt)("li",{parentName:"ol"},"Every phase can now time out \u2013 there is no indefinite wait as in the two-phase commit protocol.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Phase 1"),":\nParticipant aborts if it doesn\u2019t hear from a coordinator in time;\nCoordinator sends aborts to all if it doesn\u2019t hear from any participant."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Phase 2"),":\nIf a participant times out waiting for a coordinator, elect a new coordinator.")))),(0,o.kt)("p",null,"Let\u2019s get back to our swap contract."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Preparation phase"),":\nThe following cases are possible:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"all token contracts receive the message;"),(0,o.kt)("li",{parentName:"ul"},"the swap contract fails to wait for response from any token contract"),(0,o.kt)("li",{parentName:"ul"},"the swap contract fails itself.")),(0,o.kt)("p",null,"In the case of a fall, if a transaction isn't restarted, the swap contract will not move to the second phase and the token contracts will unlock their state using delayed messages."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img alt",src:a(8905).Z+"#gh-light-mode-only",width:"1441",height:"1243"}),"\n",(0,o.kt)("img",{alt:"img alt",src:a(5223).Z+"#gh-dark-mode-only",width:"1441",height:"1243"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Pre-Commit phase"),":\nAt this stage we can have a failure in the swap contract or in the token contract only due to the lack of gas.  To solve this problem we can use gas reservation as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The swap contract receives the information about error in its ",(0,o.kt)("inlineCode",{parentName:"li"},"handle_signal"),";"),(0,o.kt)("li",{parentName:"ul"},"Using gas reservation (so, it\u2019s necessary to care about gas reservations before), the swap contract sends a message to itself to restart the transaction from the second phase. (The same logic can also be used in the ",(0,o.kt)("inlineCode",{parentName:"li"},"preparation phase"),").")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img alt",src:a(9171).Z+"#gh-light-mode-only",width:"1596",height:"1173"}),"\n",(0,o.kt)("img",{alt:"img alt",src:a(5420).Z+"#gh-dark-mode-only",width:"1596",height:"1173"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Commit phase"),":\nAs in the previous stage we can have a failure only due to the lack of gas. Here it is not so critical, since at this stage all participants can commit themselves."),(0,o.kt)("h2",{id:"saga-pattern"},"Saga pattern"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Theory"),":\nA ",(0,o.kt)("inlineCode",{parentName:"p"},"saga")," is a sequence of local transactions. Each local transaction updates the database and publishes a message or event to trigger the next local transaction in the saga. If a local transaction fails because it violates a business rule then the saga executes a series of compensating transactions that undo the changes that were made by the preceding local transactions. Thus, Saga consists of multiple steps whereas ",(0,o.kt)("inlineCode",{parentName:"p"},"2PC")," acts like a single request.\nThere are two ways of coordination sagas:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Choreography")," - each local transaction publishes domain events that trigger local transactions in other services;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Orchestration")," - an orchestrator (object) tells the participants what local transactions to execute.")),(0,o.kt)("p",null,"We will consider the ",(0,o.kt)("inlineCode",{parentName:"p"},"orchestration based Saga")," where there would be an orchestrator (swap contract) to manage the entire operation from one center."),(0,o.kt)("p",null,"The swap operation consists of the following steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Swap contract receives a message to exchange tokens in the liquidity pool. So, it must transfer tokens A from the account to its address and then transfer tokens B to the user."),(0,o.kt)("li",{parentName:"ol"},"It creates the first task: transfer tokens from the user to the swap contract. It also creates a compensating transaction for the first task: transfer tokens from the swap contract back to the user. The second task is to transfer tokens from the swap contract to the user."),(0,o.kt)("li",{parentName:"ol"},"It starts executing the first task. If the execution fails, it cancels the transaction. If it\u2019s successful, the swap contract executes the second task;"),(0,o.kt)("li",{parentName:"ol"},"If the execution of the second task is successful, the transaction is completed. Otherwise, the swap contract executes the compensation transaction for the first task.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img alt",src:a(2752).Z+"#gh-light-mode-only",width:"1500",height:"397"}),"\n",(0,o.kt)("img",{alt:"img alt",src:a(5485).Z+"#gh-dark-mode-only",width:"1500",height:"397"})),(0,o.kt)("p",null,"It is important to note that compensatory transactions should not fail due to any logical error. They can only fall due to lack of gas. If this happens, then you need to restart the transaction again or use the gas reservation. The ",(0,o.kt)("inlineCode",{parentName:"p"},"idempotency")," of the token contract guarantees that the transaction will be completed to the end without any duplicate transactions."))}h.isMDXComponent=!0},3593:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/1.step1-dark-f14712c305ad5dcb25e26bfa5d6e6e08.png"},6836:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/1.step1-bcde9c4b053ed8ce9dad52f33f3c8e50.png"},2013:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/1.step2-dark-9d91ef78b9a0c07d2409162154a5c139.png"},8413:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/1.step2-d647dfa5fadd512f52fc89f9c6183a3b.png"},3348:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/1.step3-dark-5ae16fa99ce1ce4edcbee7559f81805e.png"},9145:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/1.step3-0b364770e9107733810a7f8c90cf56d8.png"},5209:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/2.commit-dark-8b62864524bcc649489526d835971a73.png"},5401:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/2.commit-ab5ebd7f46cf762e1ba5c4cdcd1de2c7.png"},3225:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/2.prepare-dark-c6fe206f1bb984eed7fff04b8fa8bc6c.png"},1786:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/2.prepare-5fe68cdcee4ff2fc83f296f1a20288fe.png"},5420:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/3.precommit-dark-095ce42a0c8bdf868c54dc5ff26fb736.png"},9171:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/3.precommit-34c9c8365a72ba6d1120adaabc83f5bc.png"},5223:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/3.prepare-dark-ea97c261699a829c5f86d1d128543253.png"},8905:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/3.prepare-5b72776ee099a517f4b7a33ac0d84bc5.png"},5485:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/Saga-dark-15232e7482a7f2265edbc8843c4969ed.png"},2752:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/saga-5c35daeb0e688d4cb4287c01b1ce3586.png"}}]);