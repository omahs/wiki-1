"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[6131],{3905:(e,r,t)=>{t.d(r,{Zo:()=>c,kt:()=>u});var a=t(7294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function s(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a)}return t}function n(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?s(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function i(e,r){if(null==e)return{};var t,a,o=function(e,r){if(null==e)return{};var t,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),m=function(e){var r=a.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):n(n({},r),e)),t},c=function(e){var r=m(e.components);return a.createElement(l.Provider,{value:r},e.children)},p={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},d=a.forwardRef((function(e,r){var t=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=m(t),u=o,g=d["".concat(l,".").concat(u)]||d[u]||p[u]||s;return t?a.createElement(g,n(n({ref:r},c),{},{components:t})):a.createElement(g,n({ref:r},c))}));function u(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var s=t.length,n=new Array(s);n[0]=d;var i={};for(var l in r)hasOwnProperty.call(r,l)&&(i[l]=r[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,n[1]=i;for(var m=2;m<s;m++)n[m]=t[m];return a.createElement.apply(null,n)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8187:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>n,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>m});var a=t(7462),o=(t(7294),t(3905));const s={title:"Persistent Memory",sidebar_label:"Persistent Memory",sidebar_position:4},n=void 0,i={unversionedId:"gear/technology/persist-memory",id:"gear/technology/persist-memory",title:"Persistent Memory",description:"Another distinguished feature of the Gear Protocol is the Persistent memory approach. It is what makes development easier, removes a lot of complexity and makes protocol memory management match real-life hardware and operating systems.",source:"@site/docs/gear/technology/persist-memory.md",sourceDirName:"gear/technology",slug:"/gear/technology/persist-memory",permalink:"/docs/gear/technology/persist-memory",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/gear/technology/persist-memory.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Persistent Memory",sidebar_label:"Persistent Memory",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"WebAssembly (Wasm)",permalink:"/docs/gear/technology/WASM"},next:{title:"Gear Network State",permalink:"/docs/gear/technology/state"}},l={},m=[],c={toc:m};function p(e){let{components:r,...s}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,s,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Another distinguished feature of the Gear Protocol is the Persistent memory approach. It is what makes development easier, removes a lot of complexity and makes protocol memory management match real-life hardware and operating systems."),(0,o.kt)("p",null,"Programs running in Gear Networks don\u2019t use storage but rather their full state is persisted which ensures much less API surface for blockchain context. It avoids domain-specific language features as well as allows using much more complex language constructs \u2014 persisted boxed closures, futures compositors, etc."),(0,o.kt)("p",null,"The Gear Protocol uses clever memory virtualization techniques (despite vanilla Wasm does not), memory allocation and deallocation are first-class syscalls of the protocol. Memory access is also tracked and only required pages are loaded/stored. That allows heap-allocated stack frames of smart contracts stored in the blockchain\u2019s state (typically found in futures and their compositors) to be seamlessly persisted and invoked when needed, preserving their state upon request."),(0,o.kt)("p",null,"Program code is stored as an immutable Wasm blob. Each program has a fixed amount of memory which persists between message-handling (so-called static area)."),(0,o.kt)("p",null,"Gear instance holds individual memory space per program and guarantees its persistence. A program can read and write only within its own memory space and has no access to the memory space of other programs. Individual memory space is reserved for a program during its initialization and does not require an additional fee (it is included in the program's initialization fee)."),(0,o.kt)("p",null,"A program can allocate the required amount of memory in blocks of 64KB. Each memory block allocation requires a gas fee. Each page (64KB) is stored separately on the distributed database backend, but at the run time, Gear node constructs continuous runtime memory and allows programs to run on it without reloads."),(0,o.kt)("h1",{id:"memory-parallelism"},"Memory parallelism"),(0,o.kt)("p",null,"Individual isolated memory space per program allows parallelization of message processing on a Gear node. Number of parallel processing streams equals the number of CPU cores. Each stream processes messages intended for a defined set of programs. It relates to messages sent from other programs or from outside (user\u2019s transactions)."),(0,o.kt)("p",null,"For example, given a message queue containing messages targeted to 100 different programs, Gear node runs on a network where 2 threads of processing are configured. Gear engine uses a runtime-defined number of streams (equal to number of CPU cores on a typical validator machine), divides total amount of targeted programs to number of streams and creates a message pool for each stream (50 programs per stream)."),(0,o.kt)("p",null,"Programs are distributed to separate streams and each message appears in a stream where its targeted program is defined. So, all messages addressed to a particular program appear in a single processing stream."),(0,o.kt)("p",null,"In each cycle a targeted program can have more than one message and one stream processes messages for plenty of programs. The result of message processing is a set of new messages from each stream that is added to the message queue, then the cycle repeats. The resultant messages generated during message processing are usually sent to another address (return to origin or to the next program)."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"alt text",src:t(9392).Z,width:"1400",height:"1400"})))}p.isMDXComponent=!0},9392:(e,r,t)=>{t.d(r,{Z:()=>a});const a=t.p+"assets/images/message-parallelism-f296727b5accdd4c315c190f19e0bcdb.jpg"}}]);