"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[7532],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),u=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=u(e.components);return r.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,h=p["".concat(c,".").concat(d)]||p[d]||m[d]||i;return n?r.createElement(h,o(o({ref:t},l),{},{components:n})):r.createElement(h,o({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2118:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:12},o="Supply chain",s={unversionedId:"examples/supply-chain",id:"examples/supply-chain",title:"Supply chain",description:"Introduction",source:"@site/docs/examples/supply-chain.md",sourceDirName:"examples",slug:"/examples/supply-chain",permalink:"/docs/examples/supply-chain",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/examples/supply-chain.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"Dutch Auction",permalink:"/docs/examples/dutch-auction"},next:{title:"Multisig Wallet",permalink:"/docs/examples/multisig-wallet"}},c={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Logic",id:"logic",level:2},{value:"Interface",id:"interface",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Actions",id:"actions",level:3},{value:"Program metadata and state",id:"program-metadata-and-state",level:3},{value:"Source code",id:"source-code",level:2}],l={toc:u};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"supply-chain"},"Supply chain"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"In logistics, a supply chain is a system for tracking and delivering to an end consumer various items. As a rule, such systems can't work without a lot of paperwork and other layers of bureaucracy. All of this costs a lot of time and money and increases the likelihood of an accidental error or, worst of all, a fraud. With the help of smart contract and blockchain technologies, it is possible to eliminate these problems by making a supply chain more efficient, reliable and transparent."),(0,a.kt)("p",null,"The source code of the Supply Chain smart conrtact example is avaialble on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/supply-chain"},"GitHub"),"."),(0,a.kt)("h2",{id:"logic"},"Logic"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Each newly produced item gets the NFT (in Gear's context - ",(0,a.kt)("a",{parentName:"li",href:"/docs/examples/gnft-721"},"Gear non-fungible token (gNFT)")," and its ID equals an ID of the item. Then, as an item moves along a supply chain, an item's NFT transfers between a supply chain program, item's producer, and future distributor, retailer and end consumer."),(0,a.kt)("li",{parentName:"ul"},"Anyone who knows an item's ID can get item info."),(0,a.kt)("li",{parentName:"ul"},"Sale, purchase, delivery is made in ",(0,a.kt)("a",{parentName:"li",href:"/docs/examples/gft-20"},"Gear fungible tokens (gFT)"),".")),(0,a.kt)("p",null,"Item info has the following struct:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct ItemInfo {\n    /// Item\u2019s producer [`ActorId`].\n    pub producer: ActorId,\n    /// [`ActorId`] of an item\u2019s current or past distributor (depends on item\u2019s\n    /// `state`). If it equals [`ActorId::zero()`], then it means that an item\n    /// has never had a distributor.\n    pub distributor: ActorId,\n    /// [`ActorId`] of an item\u2019s current or past retailer (depends on item\u2019s\n    /// `state`). If it equals [`ActorId::zero()`], then it means that an item\n    /// has never had a retailer.\n    pub retailer: ActorId,\n\n    pub state: ItemState,\n    /// An item\u2019s price. If it equals 0, then, depending on item\u2019s `state`, an\n    /// item is sold for free or has never been put up for sale.\n    pub price: u128,\n    /// Milliseconds during which a current seller should deliver an item.\n    pub delivery_time: u64,\n}\n")),(0,a.kt)("p",null,"And ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemState")," has the following struct and inner enums:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct ItemState {\n    pub state: ItemEventState,\n    pub by: Role,\n}\n\npub enum ItemEventState {\n    Produced,\n    Purchased,\n    Received,\n    Processed,\n    Packaged,\n    ForSale,\n    Approved,\n    Shipped,\n}\n\npub enum Role {\n    Producer,\n    Distributor,\n    Retailer,\n    Consumer,\n}\n")),(0,a.kt)("h2",{id:"interface"},"Interface"),(0,a.kt)("h3",{id:"initialization"},"Initialization"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"/// Initializes the Supply chain contract.\n///\n/// # Requirements\n/// - Each [`ActorId`] of `producers`, `distributors`, and `retailers` mustn't\n/// equal [`ActorId::zero()`].\n#[derive(Encode, Decode, Hash, TypeInfo, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub struct Initialize {\n    /// IDs of actors that'll have the right to interact with a supply chain on\n    /// behalf of a producer.\n    pub producers: Vec<ActorId>,\n    /// IDs of actors that'll have the right to interact with a supply chain on\n    /// behalf of a distributor.\n    pub distributors: Vec<ActorId>,\n    /// IDs of actors that'll have the right to interact with a supply chain on\n    /// behalf of a retailer.\n    pub retailers: Vec<ActorId>,\n\n    /// A FT contract [`ActorId`].\n    pub fungible_token: ActorId,\n    /// An NFT contract [`ActorId`].\n    pub non_fungible_token: ActorId,\n}\n")),(0,a.kt)("h3",{id:"actions"},"Actions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"/// Sends the contract info about what it should do.\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub struct Action {\n    pub action: InnerAction,\n    pub kind: TransactionKind,\n}\n\n/// A part of [`Action`].\n///\n/// Determines how an action will be processed.\n///\n/// The contract has a transaction caching mechanism for a continuation of\n/// partially processed asynchronous actions. Most often, the reason of an\n/// underprocession is the lack of gas.\n///\n/// Important notes:\n/// - Only the last sent asynchronous action for\n/// [`msg::source()`](gstd::msg::source) is cached.\n/// - Non-asynchronous actions are never cached.\n/// - There's no guarantee every underprocessed asynchronous action will be\n/// cached. Use [`StateQuery::IsActionCached`] to check if some action is cached\n/// for some [`ActorId`].\n/// - It's possible to send a retry action with a different payload, and it'll\n/// continue with it because, for some action, not all payload is saved in the\n/// cache (see [`CachedAction`]).\n/// - The cache memory has a limit, so when it's reached every oldest cached\n/// action is replaced with a new one.\n#[derive(\n    Default, Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash,\n)]\npub enum TransactionKind {\n    #[default]\n    New,\n    Retry,\n}\n\n/// A part of [`Action`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub enum InnerAction {\n    Producer(ProducerAction),\n    Distributor(DistributorAction),\n    Retailer(RetailerAction),\n    Consumer(ConsumerAction),\n}\n/// Actions for a producer.\n///\n/// Should be used inside [`InnerAction::Producer`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub enum ProducerAction {\n    /// Produces one item and a corresponding NFT with given `token_metadata`.\n    ///\n    /// Transfers the created NFT for the item to a producer\n    /// ([`msg::source()`]).\n    ///\n    /// # Requirements\n    /// - [`msg::source()`] must be a producer in a supply chain.\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Produced`] & [`Role::Producer`].\n    ///\n    /// [`msg::source()`]: gstd::msg::source\n    Produce { token_metadata: TokenMetadata },\n\n    /// Puts a produced item up for sale to distributors for given `price` on\n    /// behalf of a producer.\n    ///\n    /// Transfers an item's NFT to the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the producer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Produced`] &\n    /// [`Role::Producer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::ForSale`] & [`Role::Producer`].\n    PutUpForSale { item_id: ItemId, price: u128 },\n\n    /// Approves or not a distributor's purchase on behalf of a producer.\n    ///\n    /// If the purchase is approved, then item's [`ItemEventState`] changes to\n    /// [`Approved`](ItemEventState::Approved) and, from that moment, an item\n    /// can be shipped (by [`ProducerAction::Ship`]).\n    ///\n    /// If the purchase is **not** approved, then fungible tokens for it are\n    /// refunded from the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)) to the item's\n    /// distributor and item's [`ItemEventState`] changes back to\n    /// [`ForSale`](ItemEventState::ForSale).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the producer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Produced`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Approved`]/[`ItemEventState::ForSale`] &\n    /// [`Role::Producer`].\n    Approve {\n        item_id: ItemId,\n        /// Yes ([`true`]) or no ([`false`]).\n        approve: bool,\n    },\n\n    /// Starts a shipping of a purchased item to a distributor on behalf of a\n    /// producer.\n    ///\n    /// Starts the countdown for the delivery time specified for the item in\n    /// [`DistributorAction::Purchase`].\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the producer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Approved`] &\n    /// [`Role::Producer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Shipped`] & [`Role::Producer`].\n    Ship(ItemId),\n}\n\n/// Actions for a distributor.\n///\n/// Should be used inside [`InnerAction::Distributor`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash)]\npub enum DistributorAction {\n    /// Purchases an item from a producer on behalf of a distributor.\n    ///\n    /// Transfers fungible tokens for purchasing the item to the Supply chain\n    /// contract ([`exec::program_id()`](gstd::exec::program_id)) until the item\n    /// is received (by [`DistributorAction::Receive`]).\n    ///\n    /// **Note:** the item's producer must approve or not this purchase by\n    /// [`ProducerAction::Approve`].\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be a distributor.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::ForSale`] &\n    /// [`Role::Producer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Purchased`] & [`Role::Distributor`].\n    Purchase {\n        item_id: ItemId,\n        /// Milliseconds during which the producer of an item should deliver it.\n        /// A countdown starts after [`ProducerAction::Ship`] is executed.\n        delivery_time: u64,\n    },\n\n    /// Receives a shipped item from a producer on behalf of a distributor.\n    ///\n    /// Depending on the time spent on a delivery, transfers fungible tokens for\n    /// purchasing the item from the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)) to the item's producer\n    /// or, as a penalty for being late, refunds a half or all of them to the\n    /// item's distributor ([`msg::source()`]).\n    ///\n    /// Transfers an item's NFT to the distributor ([`msg::source()`]).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`] must be the distributor of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Shipped`] &\n    /// [`Role::Producer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Received`] & [`Role::Distributor`].\n    ///\n    /// [`msg::source()`]: gstd::msg::source\n    Receive(ItemId),\n\n    /// Processes a received item on behalf of a distributor.\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Received`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Processed`] & [`Role::Distributor`].\n    Process(ItemId),\n\n    /// Packages a processed item on behalf of a distributor.\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Processed`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Packaged`] & [`Role::Distributor`].\n    Package(ItemId),\n\n    /// Puts a packaged item up for sale to retailers for given `price` on\n    /// behalf of a distributor.\n    ///\n    /// Transfers an item's NFT to the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Packaged`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::ForSale`] & [`Role::Distributor`].\n    PutUpForSale { item_id: ItemId, price: u128 },\n\n    /// Approves or not a retailer's purchase on behalf of a distributor.\n    ///\n    /// If the purchase is approved, then item's [`ItemEventState`] changes to\n    /// [`Approved`](ItemEventState::Approved) and, from that moment, an item\n    /// can be shipped (by [`DistributorAction::Ship`]).\n    ///\n    /// If the purchase is **not** approved, then fungible tokens for it are\n    /// refunded from the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)) to the item's retailer\n    /// and item's [`ItemEventState`] changes back to\n    /// [`ForSale`](ItemEventState::ForSale).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Purchased`] &\n    /// [`Role::Retailer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Approved`]/[`ItemEventState::ForSale`] &\n    /// [`Role::Distributor`].\n    Approve {\n        item_id: ItemId,\n        /// Yes ([`true`]) or no ([`false`]).\n        approve: bool,\n    },\n\n    /// Starts a shipping of a purchased item to a retailer on behalf of a\n    /// distributor.\n    ///\n    /// Starts the countdown for the delivery time specified for the item in\n    /// [`RetailerAction::Purchase`].\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Approved`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Shipped`] & [`Role::Distributor`].\n    Ship(ItemId),\n}\n\n/// Actions for a retailer.\n///\n/// Should be used inside [`InnerAction::Retailer`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash)]\npub enum RetailerAction {\n    /// Purchases an item from a distributor on behalf of a retailer.\n    ///\n    /// Transfers fungible tokens for purchasing the item to the Supply chain\n    /// contract ([`exec::program_id()`](gstd::exec::program_id)) until the item\n    /// is received (by [`RetailerAction::Receive`]).\n    ///\n    /// **Note:** the item's distributor must approve or not this purchase by\n    /// [`DistributorAction::Approve`].\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be a retailer.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::ForSale`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Purchased`] & [`Role::Retailer`].\n    Purchase {\n        item_id: ItemId,\n        /// Milliseconds during which the distributor of an item should deliver\n        /// it. A countdown starts after [`DistributorAction::Ship`] is\n        /// executed.\n        delivery_time: u64,\n    },\n\n    /// Receives a shipped item from a distributor on behalf of a retailer.\n    ///\n    /// Depending on the time spent on a delivery, transfers fungible tokens for\n    /// purchasing the item from the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)) to the item's\n    /// distributor or, as a penalty for being late, refunds a half or all of\n    /// them to the item's retailer ([`msg::source()`]).\n    ///\n    /// Transfers an item's NFT to the retailer ([`msg::source()`]).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`] must be the retailer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Shipped`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Received`] & [`Role::Retailer`].\n    ///\n    /// [`msg::source()`]: gstd::msg::source\n    Receive(ItemId),\n\n    /// Puts a received item up for sale to consumers for given `price` on\n    /// behalf of a retailer.\n    ///\n    /// Transfers an item's NFT to the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the retailer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Received`] &\n    /// [`Role::Retailer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::ForSale`] & [`Role::Retailer`].\n    PutUpForSale { item_id: ItemId, price: u128 },\n}\n\n/// Actions for a consumer.\n///\n/// Should be used inside [`InnerAction::Consumer`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash)]\npub enum ConsumerAction {\n    /// Purchases an item from a retailer.\n    ///\n    /// Transfers fungible tokens for purchasing the item to its retailer.\n    ///\n    /// Transfers an item's NFT to the consumer\n    /// ([`msg::source()`](gstd::msg::source)).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::ForSale`] &\n    /// [`Role::Retailer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Purchased`] & [`Role::Consumer`].\n    Purchase(ItemId),\n}\n")),(0,a.kt)("h3",{id:"program-metadata-and-state"},"Program metadata and state"),(0,a.kt)("p",null,"Metadata interface description:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct ContractMetadata;\n\nimpl Metadata for ContractMetadata {\n    type Init = InOut<Initialize, Result<(), Error>>;\n    type Handle = InOut<Action, Result<Event, Error>>;\n    type Reply = ();\n    type Others = ();\n    type Signal = ();\n    type State = State;\n}\n")),(0,a.kt)("p",null,"To display the full contract state information, the ",(0,a.kt)("inlineCode",{parentName:"p"},"state()")," function is used:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\nextern "C" fn state() {\n    reply(common_state())\n        .expect("Failed to encode or reply with `<ContractMetadata as Metadata>::State` from `state()`");\n}\n')),(0,a.kt)("p",null,"To display only necessary certain values from the state, you need to write a separate crate. In this crate, specify functions that will return the desired values from the ",(0,a.kt)("inlineCode",{parentName:"p"},"State")," struct. For example - ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/supply-chain/tree/master/state"},"gear-dapps/supply-chain/state"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[metawasm]\npub trait Metawasm {\n    type State = <ContractMetadata as Metadata>::State;\n\n    fn item_info(item_id: ItemId, state: Self::State) -> Option<ItemInfo> {\n        state.item_info(item_id)\n    }\n\n    fn participants(state: Self::State) -> Participants {\n        state.participants()\n    }\n\n    fn roles(actor: ActorId, state: Self::State) -> Vec<Role> {\n        state.roles(actor)\n    }\n\n    fn existing_items(state: Self::State) -> Vec<(ItemId, ItemInfo)> {\n        state.items\n    }\n\n    fn fungible_token(state: Self::State) -> ActorId {\n        state.fungible_token\n    }\n\n    fn non_fungible_token(state: Self::State) -> ActorId {\n        state.non_fungible_token\n    }\n\n    fn is_action_cached(actor_action: ActorIdInnerSupplyChainAction, state: Self::State) -> bool {\n        let (actor, action) = actor_action;\n\n        state.is_action_cached(actor, action)\n    }\n}\n\npub type ActorIdInnerSupplyChainAction = (ActorId, InnerAction);\n")),(0,a.kt)("h2",{id:"source-code"},"Source code"),(0,a.kt)("p",null,"The source code of this example of a supply chain smart contract and an implementation of its testing is available on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/supply-chain"},"GitHub"),". They can be used as is or modified to suit your own scenarios."),(0,a.kt)("p",null,"For more details about testing smart contracts written on Gear, refer to the ",(0,a.kt)("a",{parentName:"p",href:"/docs/developing-contracts/testing"},"Program Testing")," article."))}m.isMDXComponent=!0}}]);