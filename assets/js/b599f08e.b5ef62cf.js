"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[1759],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=l(a),p=r,m=h["".concat(c,".").concat(p)]||h[p]||d[p]||i;return a?n.createElement(m,s(s({ref:t},u),{},{components:a})):n.createElement(m,s({ref:t},u))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},121:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var n=a(7462),r=(a(7294),a(3905));const i={sidebar_position:3,sidebar_label:"Gear Distinctive Features"},s="Gear Distinctive Features",o={unversionedId:"gear/distinctive-features",id:"gear/distinctive-features",title:"Gear Distinctive Features",description:"Truly decentralized",source:"@site/docs/gear/distinctive-features.md",sourceDirName:"gear",slug:"/gear/distinctive-features",permalink:"/docs/gear/distinctive-features",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/gear/distinctive-features.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Gear Distinctive Features"},sidebar:"tutorialSidebar",previous:{title:"Why do we build Gear?",permalink:"/docs/gear/why"},next:{title:"Substrate",permalink:"/docs/gear/technology/substrate"}},c={},l=[{value:"Truly decentralized",id:"truly-decentralized",level:2},{value:"Continuing messaging automation",id:"continuing-messaging-automation",level:2},{value:"Use cases",id:"use-cases",level:2},{value:"NFTs",id:"nfts",level:3},{value:"Gaming",id:"gaming",level:3},{value:"DeFi",id:"defi",level:3}],u={toc:l};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"gear-distinctive-features"},"Gear Distinctive Features"),(0,r.kt)("h2",{id:"truly-decentralized"},"Truly decentralized"),(0,r.kt)("p",null,"One of the well-known drawbacks of other-platform\u2019s smart contracts is that they cannot trigger their own functions. Instead, to run certain functions they require an external component or service to trigger on-chain transactions."),(0,r.kt)("p",null,"While some smart contract logic may rely on users to initiate transactions and awaken the contract, many cases require a trigger when certain conditions are met, such as reaching a specific point in time or the occurrence of a particular event. In the past, this has either limited the capabilities of smart contracts or required developers to introduce a centralized service to trigger smart contracts."),(0,r.kt)("p",null,"Now thanks to Gear Protocol's support for asynchronous messaging, contract developers can implement arbitrary contract logic with ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/delayed-messages"},"delayed messages")," that can wake the contract after a specified period of time or in response to certain events. This enables a much more extensive range of use cases for smart contracts, unlocks new decentralized functionality, and unlocks more value for users in the blockchain ecosystem."),(0,r.kt)("h2",{id:"continuing-messaging-automation"},"Continuing messaging automation"),(0,r.kt)("p",null,"The execution of any messages in Gear, including the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/system-signals"},"system messages"),', consumes "gas". The Gear Protocol introduces the concept of ',(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/gas-reservation"},"gas reservation"),', which allows for the creation of gas pools that can be used by programs for further execution. Each pool is unique to the program that creates it, and the gas from the pool can be consumed by the program if its "gas_available" is not sufficient.'),(0,r.kt)("p",null,"One of the key benefits of gas reservation is the ability to send ",(0,r.kt)("strong",{parentName:"p"},"delayed messages")," that can be triggered automatically at a specific time in the future. These messages, like any other message in Gear, can invoke another smart contract in the network or appear in the user's mailbox."),(0,r.kt)("p",null,"Perhaps most interestingly, gas reservation allows a program to send a message to itself at a later time, allowing it to continue execution after a defined period. This effectively enables a smart contract to execute itself an ",(0,r.kt)("strong",{parentName:"p"},"unlimited")," number of times (provided that enough gas is available for the execution)."),(0,r.kt)("p",null,"This opens up a wide range of possibilities for the implementation of functional logic related to ",(0,r.kt)("strong",{parentName:"p"},"continuing messaging automation")," in smart contracts. Delayed messages are similar to cron jobs, which cannot be implemented in smart contracts on other blockchain platforms without the use of external resources. The remarkable advantage of this solution is that it eliminates the need for centralized components in dApps, ensuring they function ",(0,r.kt)("strong",{parentName:"p"},"completely on-chain")," and are fully decentralized and autonomous."),(0,r.kt)("h2",{id:"use-cases"},"Use cases"),(0,r.kt)("p",null,"For instance, let's consider some use case examples that become achievable:"),(0,r.kt)("h3",{id:"nfts"},"NFTs"),(0,r.kt)("p",null,"Non-Fungible Tokens (NFTs) are unique digital assets that can be owned and traded on blockchain networks. One of the key features of NFTs is that they can be dynamic, meaning that their properties can be changed based on certain conditions. Dynamic NFTs can be updated immediately by their owner or gradually using delayed messages."),(0,r.kt)("p",null,"This can be useful in a variety of situations, such as updating an NFT based on changes in its price, as is done in the Curse NFT using Oracles, or in gaming applications where the properties of an NFT might change over time."),(0,r.kt)("p",null,"There are scenarios in which NFTs are updated:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The user can send a message to update the NFT immediately"),(0,r.kt)("li",{parentName:"ul"},"The NFT contract can send a message to itself at regular intervals to update the token's properties"),(0,r.kt)("li",{parentName:"ul"},"The NFT contract can send a delayed message to another actor (such as a program or account) and change the NFT's properties based on the result of processing that message.")),(0,r.kt)("p",null,"Overall, the ability to update NFTs dynamically opens up a wide range of possibilities for their use in a variety of applications."),(0,r.kt)("h3",{id:"gaming"},"Gaming"),(0,r.kt)("p",null,"Tamagotchi is a classic digital pet game where players must care for a virtual creature by providing it food, attention, and other forms of care. As a dynamic NFT, a Tamagotchi can change its appearance based on its properties (such as hunger, fatigue, or happiness) and can notify the user when it needs to be fed or played with. The user can feed the NFT with gas, which is used to send delayed messages that are required to update the Tamagotchi's state."),(0,r.kt)("p",null,'"Game strategies battle" is a game in which several programs compete with each other using different algorithms or strategies. The game can be based on a variety of classic games, such as checkers, tic-tac-toe, races, or monopoly. Each participant creates a smart contract with their own game strategy and uploads it to the blockchain. The programs then play against each other until someone wins or the gas runs out. If the gas runs out, one of the participants can continue the game by sending a message with more gas. This allows the game to continue indefinitely, with the most effective strategy ultimately emerging as the winner.'),(0,r.kt)("h3",{id:"defi"},"DeFi"),(0,r.kt)("p",null,'Decentralized finance (DeFi) applications can improve the user experience by implementing delayed messages. For example, when users deposit tokens into a liquidity pool on an automated market maker (AMM) or participate in staking to earn rewards, they often have to manually claim their earnings (known as "harvesting yield").'),(0,r.kt)("p",null,"With the Gear Protocol, users can enjoy a set-and-forget DeFi experience where their earnings are automatically deposited into their accounts without any manual intervention. Rewards are regularly harvested, swapped for the original vault asset, and deposited again for compound farming, allowing users to earn even more without having to take any additional action."),(0,r.kt)("p",null,"In general, the use of delayed messages in DeFi can greatly improve the user experience by making it easier for users to earn rewards and take advantage of the benefits of DeFi without constantly having to monitor and manage their assets. This can help drive broader adoption of DeFi and unlock new opportunities for growth in the industry."))}d.isMDXComponent=!0}}]);